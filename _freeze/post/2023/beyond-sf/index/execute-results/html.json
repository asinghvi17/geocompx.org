{
  "hash": "39dad67ef1fc4267dd872296fc645ae2",
  "result": {
    "markdown": "---\ntitle: \"R-spatial beyond sf\"\nauthor: \n  - name: Josiah Parry\n    affiliation: Esri\n    orcid: 0000-0001-9910-865X\ncategories: \n  - posts\n  - rstats\ntags: [rspatial]\ndate: \"2023-09-08\"\nslug: r-spatial-beyond-sf\n---\n\n\n\n\n**sf** has transformed the R ecosystem and helped pave the way for wider adoption of geospatial workflows by R users. The R-spatial ecosystem, however, is much bigger than just **sf**. There are lower level packages such as **geos**, **wk**, and **s2** that provide access to geometries and algorithms outside of the context of **sf**. These packages are often more performant than **sf** but require a different frame of mind when using them.\n\nThe goal of this post is to demystify the way in which **sf** represents geometries and explain how other geometry libraries can be used alongside typical **sf** workflows.\n\n## Understanding `sf`\n\nMost R users that do geospatial analysis are familiar with **sf** and understand spatial workflows in that context only. Many users of **sf** view it as this magical data frame that lets you do spatial analysis—and that is exactly how it feels! This means that **sf** has done a great job in making spatial analysis feel a lot easier for the vast majority of R users. \n\n:::{.callout-note}\nRead more about **sf** in [Spatial Data Science](https://r-spatial.org/book/07-Introsf.html#sec-sfintro)\n:::\n\nBut it is good to understand **sf** in a more fundamental way. **sf** is named after the [Simple Feature Access Standard](https://en.wikipedia.org/wiki/Simple_Features). Simple features are an agreed upon way to represent \"geometric primitives\"—things like `Point`s, `LineString`s, `Polygon`s, and their `Multi`- types. The **sf** package builds a hierarchy off of these. We have `sfg`, `sfc`, and `sf` objects.\n\n[![](https://r-spatial.github.io/sf/articles/sf_xfig.png)](https://r-spatial.github.io/sf/articles/sf1.html#sf-objects-with-simple-features)\n\n### `sfg` objects\n\nAt the core is the `sfg` class which is the representation of a simple feature geometry. `sfg` class objects are representations of a simple feature. They are a single geometry at a time. We can think of them as a scalar value (even though R does not have the concept of a scalar).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(sf)\n#> Linking to GEOS 3.11.1, GDAL 3.6.4, PROJ 9.1.1; sf_use_s2() is TRUE\n\n# create a point\npnt <- st_point(c(0, 10))\n\n# create a line\nln <- st_linestring(matrix(c(0, 1, 0, 0), ncol = 2))\n\nclass(pnt)\n#> [1] \"XY\"    \"POINT\" \"sfg\"\nclass(ln)\n#> [1] \"XY\"         \"LINESTRING\" \"sfg\"\n```\n:::\n\n\nEach scalar value can be used independently which is useful in itself. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_length(ln)\n#> [1] 1\n```\n:::\n\n`sfg` objects are very simple objects constructed of numeric vectors, matrices, and lists of matrices. They also have no sense of a coordinate reference system (CRS). More often than not, though, we want to have a vector of geometries—one for each element in a dataset, for example. In **sf**, a vector of geometries is stored in an `sfc` object.\n\n### `sfc` objects\n\n`sfc` is short for **s**imple **f**eature **c**olumn. You might think that you could create a vector of geometries by combining them using `c()` but that would be wrong\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(pnt, pnt)\n#> MULTIPOINT ((0 10), (0 10))\nc(pnt, ln)\n#> GEOMETRYCOLLECTION (POINT (0 10), LINESTRING (0 0, 1 0))\n```\n:::\n\n`sfg` objects behave like scalars so combining them creates either a `Multi`- type of the `sfg` or a geometry collection (another type of simple feature).\n\nTo create a vector of geometries you must use `st_sfc()`. `st_sfc()` is the construct for creating a \"simple feature geometry list column.\" It lets you also set a number of attributes that are associated with the vector. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_sfc(pnt, pnt)\n#> Geometry set for 2 features \n#> Geometry type: POINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 0 ymin: 10 xmax: 0 ymax: 10\n#> CRS:           NA\n#> POINT (0 10)\n#> POINT (0 10)\n```\n:::\n\n\nEach `sfc` object contains attributes such as a CRS (optional), bounding box, and precision.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(\n  st_sfc(pnt, pnt), \n  st_sfc(pnt),\n  st_sfc(ln)\n)\n#> Geometry set for 4 features \n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: 0 ymin: 0 xmax: 1 ymax: 10\n#> CRS:           NA\n#> POINT (0 10)\n#> POINT (0 10)\n#> POINT (0 10)\n#> LINESTRING (0 0, 1 0)\n```\n:::\n\n\nUnder the hood, this is just a list of `sfg` objects. Remember, it's not magic! \n\n\n::: {.cell}\n\n```{.r .cell-code}\nunclass(st_sfc(pnt, pnt))\n#> [[1]]\n#> POINT (0 10)\n#> \n#> [[2]]\n#> POINT (0 10)\n#> \n#> attr(,\"precision\")\n#> [1] 0\n#> attr(,\"bbox\")\n#> xmin ymin xmax ymax \n#>    0   10    0   10 \n#> attr(,\"crs\")\n#> Coordinate Reference System: NA\n#> attr(,\"n_empty\")\n#> [1] 0\n```\n:::\n\n\nSince `sfc` objects are vectors, they can be included as a column in a data frame. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\n  geo = st_sfc(pnt, pnt)\n)\n\ndf\n#>       geometry\n#> 1 POINT (0 10)\n#> 2 POINT (0 10)\n\nclass(df)\n#> [1] \"data.frame\"\n```\n:::\n\n\n## Geometry and data.frames\n\nHaving geometry included in a data frame was a huge win for the R community because this means that attributes can be included along with geometries. Further, geometries in a data frame means that they are dplyr compatible. \n\nFor example we can create a vector of points from the `x` and `y` columns from the `diamonds` dataset in `ggplot2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(diamonds, package = \"ggplot2\")\n\npnts <- purrr::map2( # <1>\n  diamonds$x, \n  diamonds$y, \n  function(.x, .y) st_point(c(.x, .y)) # <2>\n) |> \n  st_sfc() # <3>\n```\n:::\n\n1. We iterate over both the x and y columns in the diamonds dataset returning a list\n2. Each value of `x` and `y` are accessed through the placeholder `.x` and `.y` based on their position in the `map2()` function. `st_point()` takes a length 2 numeric vector and returns a single `sfg` `POINT` object.\n3. We pass the list of `sfg` objects to create an `sfc`\n\nWe can included this in a data frame \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr, warn.conflicts = FALSE)\n\ndmnd <- diamonds |> \n  select(price, clarity) |> \n  bind_cols(geometry = pnts)\n\nhead(dmnd)\n#> # A tibble: 6 × 3\n#>   price clarity    geometry\n#>   <int> <ord>       <POINT>\n#> 1   326 SI2     (3.95 3.98)\n#> 2   326 SI1     (3.89 3.84)\n#> 3   327 VS1     (4.05 4.07)\n#> 4   334 VS2      (4.2 4.23)\n#> 5   335 SI2     (4.34 4.35)\n#> 6   336 VVS2    (3.94 3.96)\n```\n:::\n\n\nNow we have a tibble with price, clarity, and geometry! Huge win! What if we wanted to calculate the average price by clarity and keep the geometries?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmnd |> \n  group_by(clarity) |> \n  summarise(avg_price = mean(price))\n#> # A tibble: 8 × 2\n#>   clarity avg_price\n#>   <ord>       <dbl>\n#> 1 I1          3924.\n#> 2 SI2         5063.\n#> 3 SI1         3996.\n#> 4 VS2         3925.\n#> 5 VS1         3839.\n#> 6 VVS2        3284.\n#> 7 VVS1        2523.\n#> 8 IF          2865.\n```\n:::\n\n\nUnfortunately, we lose the geometry just like we would for any other column that wasn't included in the `summarise()` call. To keep it, we would need to perform an operation on the geometry itself. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmnd |> \n  group_by(clarity) |> \n  summarise(\n    avg_price = mean(price),\n    geometry = st_union(geometry)\n  )\n#> # A tibble: 8 × 3\n#>   clarity avg_price                                                     geometry\n#>   <ord>       <dbl>                                                 <MULTIPOINT>\n#> 1 I1          3924. ((4.33 4.29), (4.33 4.36), (4.36 4.33), (4.38 4.42), (4.39 …\n#> 2 SI2         5063. ((0 0), (0 6.62), (3.79 3.75), (3.84 3.82), (3.87 3.85), (3…\n#> 3 SI1         3996. ((3.88 3.84), (3.89 3.84), (3.9 3.85), (3.93 3.96), (3.95 3…\n#> 4 VS2         3925. ((0 0), (3.73 3.68), (3.73 3.71), (3.74 3.71), (3.76 3.73),…\n#> 5 VS1         3839. ((0 0), (3.83 3.85), (3.84 3.87), (3.86 3.89), (3.88 3.9), …\n#> 6 VVS2        3284. ((3.83 3.86), (3.85 3.89), (3.85 3.9), (3.85 3.91), (3.86 3…\n#> 7 VVS1        2523. ((0 0), (3.83 3.85), (3.87 3.9), (3.88 3.95), (3.88 3.99), …\n#> 8 IF          2865. ((3.86 3.88), (3.89 3.9), (3.91 3.95), (3.92 3.94), (3.93 3…\n```\n:::\n\n\nWouldn't it be nice if the geometry knew to do that? Well, that is exactly what `sf` objects are.\n\n## `sf` objects\n\n`sf` objects are just data frames with a geometry column that is *sticky* and *smart.* We can create an `sf` object if an `sfc` column is present in a data frame by using `st_as_sf()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmnd_sf <- st_as_sf(dmnd)\n```\n:::\n\n\nDoing this creates an object of class `sf`. The two things that make an `sf` object so special are the class `sf` and the attribute `sf_column`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(dmnd_sf, \"sf_column\") # <1>\n#> [1] \"geometry\"\n```\n:::\n\n1. `attr()` lets us access a single attribute by name\nThis attribute tells us which column is the geometry. Because we have this `sf` can implement its own methods for common functions like `select()`, `mutate()`, `aggregate()`, `group_by()`, etc which always keep the `attr(x, \"sf_column\")` attached to the data frame. \nHaving the class and attribute allow methods like `summarise()` to be written for the class itself and handle the things like unioning geometry for us. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndmnd_sf |> \n  group_by(clarity) |> \n  summarise(avg_price = mean(price))\n#> Simple feature collection with 8 features and 2 fields\n#> Geometry type: MULTIPOINT\n#> Dimension:     XY\n#> Bounding box:  xmin: 0 ymin: 0 xmax: 10.74 ymax: 58.9\n#> CRS:           NA\n#> # A tibble: 8 × 3\n#>   clarity avg_price                                                     geometry\n#>   <ord>       <dbl>                                                 <MULTIPOINT>\n#> 1 I1          3924. ((4.33 4.29), (4.33 4.36), (4.36 4.33), (4.38 4.42), (4.39 …\n#> 2 SI2         5063. ((0 0), (0 6.62), (3.79 3.75), (3.84 3.82), (3.87 3.85), (3…\n#> 3 SI1         3996. ((3.88 3.84), (3.89 3.84), (3.9 3.85), (3.93 3.96), (3.95 3…\n#> 4 VS2         3925. ((0 0), (3.73 3.68), (3.73 3.71), (3.74 3.71), (3.76 3.73),…\n#> 5 VS1         3839. ((0 0), (3.83 3.85), (3.84 3.87), (3.86 3.89), (3.88 3.9), …\n#> 6 VVS2        3284. ((3.83 3.86), (3.85 3.89), (3.85 3.9), (3.85 3.91), (3.86 3…\n#> 7 VVS1        2523. ((0 0), (3.83 3.85), (3.87 3.9), (3.88 3.95), (3.88 3.99), …\n#> 8 IF          2865. ((3.86 3.88), (3.89 3.9), (3.91 3.95), (3.92 3.94), (3.93 3…\n```\n:::\n\nNote that this is just like what we wrote earlier except that we didn't have to handle the geometry column manually. If we compare these two approaches and ignore attribute difference like `sf_column` and `class` we can see that they are identical.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- dmnd |> \n  group_by(clarity) |> \n  summarise(\n    avg_price = mean(price),\n    geometry = st_union(geometry)\n  )\n\ny <- dmnd_sf |> \n  group_by(clarity) |> \n  summarise(avg_price = mean(price))\n\nall.equal(x, y, check.attributes = FALSE) # <1>\n#> [1] TRUE\n```\n:::\n\n1. We ignore attributes because they _will_ be different because the classes are different.\n\n## Other geometry vectors\n\nKnowing how **sf** works can be helpful for understanding how we can ease our reliance on it for all geospatial operations. Instead of thinking of the entire sf data frame as the thing that handles all geometry operations we now know that it is the `sfc` geometry column. \n\nIn R there are different ways of representing geometry besides `sfc` vectors. The packages `s2`, `geos`, `wk`, and `rsgeo` all provide different vectors of geometries that can be used. \n\nThese libraries are very handy for doing geometric operations. Each of these packages tend to be better at one thing than another, and each have their place. You might find big speed improvements if you opt to use one of these libraries instead of **sf** for certain things.\n\nTake for example calculating the length of linestrings on a geodesic. We can use the `roxel` dataset from `{sfnetworks}`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(roxel, package = \"sfnetworks\")\n```\n:::\n\n\nTo illustrate, we can extract the geometry column and cast it as an `rsgeo` class object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rsgeo)\ngeo <- roxel$geometry\nrs <- as_rsgeo(geo)\n```\n:::\n\n\nWe can then use the functions `st_length()` and `length_haversine()` respectively to compute the length of linestrings. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbench::mark(\n  st_length(geo),\n  length_haversine(rs),\n  check = FALSE # <1>\n)\n#> # A tibble: 2 × 6\n#>   expression                min   median `itr/sec` mem_alloc `gc/sec`\n#>   <bch:expr>           <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n#> 1 st_length(geo)         6.34ms    6.8ms      140.    2.84MB     2.09\n#> 2 length_haversine(rs) 457.01µs  515.3µs     1659.     8.8KB     0\n```\n:::\n\n1. `check = FALSE` because the distances are ever so slightly different likely due to floating point rounding or the radius of the earth that is used.\n\nThis is markedly faster when using **rsgeo**. We also do not have to extract the vector and work with it as its own object. Any vector can be included in a data frame, remember? \n\n\n::: {.cell}\n\n```{.r .cell-code}\nroxel |> \n  as_tibble() |> \n  mutate(\n    geometry = as_rsgeo(geometry),\n    length = length_haversine(geometry)\n    ) |> \n  select(name, type, length, geometry)\n#> # A tibble: 851 × 4\n#>    name                  type        length\n#>    <chr>                 <fct>        <dbl>\n#>  1 Havixbecker Strasse   residential   28.8\n#>  2 Pienersallee          secondary    108. \n#>  3 Schulte-Bernd-Strasse residential   54.3\n#>  4 <NA>                  path         155. \n#>  5 Welsingheide          residential  209. \n#>  6 <NA>                  footway       63.0\n#>  7 <NA>                  footway       42.2\n#>  8 <NA>                  path          45.3\n#>  9 <NA>                  track        348. \n#> 10 <NA>                  track        145. \n#> # ℹ 841 more rows\n#> # ℹ 1 more variable: geometry <r_LINEST>\n```\n:::\n\n\nThis same approach can work for other libraries such as **geos**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(geos)\n\nroxel |> \n  as_tibble() |> \n  mutate(\n    geometry = as_geos_geometry(geometry),\n    length = geos_length(geometry)\n    ) |> \n  select(name, type, length, geometry)\n#> # A tibble: 851 × 4\n#>    name                  type          length geometry                          \n#>    <chr>                 <fct>          <dbl> <geos_geom>                       \n#>  1 Havixbecker Strasse   residential 0.000331 <LINESTRING (7.53372 51.95556, 7.…\n#>  2 Pienersallee          secondary   0.00101  <LINESTRING (7.53244 51.95422, 7.…\n#>  3 Schulte-Bernd-Strasse residential 0.000505 <LINESTRING (7.53271 51.95209, 7.…\n#>  4 <NA>                  path        0.00201  <LINESTRING [7.5382 51.945...7.54…\n#>  5 Welsingheide          residential 0.00188  <LINESTRING (7.53767 51.9475, 7.5…\n#>  6 <NA>                  footway     0.000585 <LINESTRING (7.54379 51.94733, 7.…\n#>  7 <NA>                  footway     0.000408 <LINESTRING (7.54012 51.94478, 7.…\n#>  8 <NA>                  path        0.000628 <LINESTRING (7.53822 51.94546, 7.…\n#>  9 <NA>                  track       0.00430  <LINESTRING [7.5401 51.945...7.54…\n#> 10 <NA>                  track       0.00162  <LINESTRING [7.5412 51.946...7.54…\n#> # ℹ 841 more rows\n```\n:::\n\n\nIf you plan on doing more than just one operation, it is best to convert to the desired geometry type only once and then use it in subsequent calls. Converting from one geometry type can take some time and add additional unwanted overhead if you're doing it all the time. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nroxy_geos <- roxel |> \n  st_transform(25832) |> # <1>\n  as_tibble() |> # <2>\n  mutate(geometry = as_geos_geometry(geometry)) # <3>\n```\n:::\n\n1. We project our dataset to use meters\n2. We remove the `sf` class so we can modify the geometry column\n3. We update the geometry from an `sfc` to a `geos_geometry`\n\nWith a geometry column that is a `geos_geometry`, you can use the functions from the **geos** package to perform your analyses. And, if doing larger scale analyses, it might be faster and more memory efficient!\n\n\n:::{.panel-tabset}\n\n## geos \n\n::: {.cell}\n\n```{.r .cell-code}\nroxy_geos |> \n  mutate(length = geos_length(geometry)) |> \n  group_by(type) |> \n  summarise(\n    geometry = geos_unary_union(geos_make_collection(geometry)),\n    avg_len = sum(length)\n  ) \n#> # A tibble: 9 × 3\n#>   type         geometry                                                  avg_len\n#>   <fct>        <geos_geom>                                                 <dbl>\n#> 1 cycleway     <MULTILINESTRING [399010 5756791...400105 5757567]>        2740. \n#> 2 footway      <MULTILINESTRING [398732 5755903...399949 5757266]>        4212. \n#> 3 path         <MULTILINESTRING [398473 5755558...399961 5757747]>        7525. \n#> 4 pedestrian   <LINESTRING (399313.41032 5756903.27258, 399269.10927 57…    44.8\n#> 5 residential  <MULTILINESTRING [398511 5755623...400125 5757523]>       22495. \n#> 6 secondary    <MULTILINESTRING [398476 5755557...400104 5757548]>        3946. \n#> 7 service      <MULTILINESTRING [398470 5755810...399995 5757577]>        6600. \n#> 8 track        <MULTILINESTRING [399654 5755892...399975 5757362]>         974. \n#> 9 unclassified <MULTILINESTRING [398655 5755557...399971 5757726]>        1973.\n```\n:::\n\n\n## sf\n\n\n::: {.cell}\n\n```{.r .cell-code}\nroxel |> \n  mutate(length = st_length(geometry)) |> \n  group_by(type) |> \n  summarise(avg_len = sum(length)) \n#> Simple feature collection with 9 features and 2 fields\n#> Geometry type: GEOMETRY\n#> Dimension:     XY\n#> Bounding box:  xmin: 7.522594 ymin: 51.94151 xmax: 7.546705 ymax: 51.9612\n#> Geodetic CRS:  WGS 84\n#> # A tibble: 9 × 3\n#>   type         avg_len                                                  geometry\n#>   <fct>            [m]                                            <GEOMETRY [°]>\n#> 1 cycleway      2735.  MULTILINESTRING ((7.535912 51.95764, 7.536254 51.95772, …\n#> 2 footway       4206.  MULTILINESTRING ((7.543791 51.94733, 7.54369 51.94686, 7…\n#> 3 path          7513.  MULTILINESTRING ((7.523003 51.95298, 7.523524 51.95306),…\n#> 4 pedestrian      44.7         LINESTRING (7.534819 51.95371, 7.534176 51.95364)\n#> 5 residential  22457.  MULTILINESTRING ((7.533722 51.95556, 7.533461 51.95576),…\n#> 6 secondary     3939.  MULTILINESTRING ((7.532442 51.95422, 7.53236 51.95377, 7…\n#> 7 service       6589.  MULTILINESTRING ((7.532238 51.95388, 7.532069 51.9535, 7…\n#> 8 track          972.  MULTILINESTRING ((7.540063 51.94468, 7.540338 51.94468, …\n#> 9 unclassified  1968.  MULTILINESTRING ((7.534918 51.94681, 7.535121 51.94688),…\n```\n:::\n\n\n:::\n\n## Continuing your R-spatial journey\n\nWith this, I encourage you to look at other geometry libraries available in the R ecosystem. Some of the notable ones are: \n\n- [s2](https://r-spatial.github.io/s2/index.html) for spherical geometry operations with google s2\n- [geos](https://paleolimbot.github.io/geos/) bindings to the powerful libgeos C library\n- [rsgeo](https://rsgeo.josiahparry.com) bindings to the GeoRust geo-types and geo crates\n- [wk](https://paleolimbot.github.io/wk/) for low level generic geometry interface with C and C++ APIs\n\nEach library can convert to and from **sf** geometries as well.\n\nHappy programming! \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}